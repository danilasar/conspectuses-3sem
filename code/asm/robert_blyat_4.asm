
.model small                     ; Указываем модель памяти (маленькая)
.stack 100h                      ; Задаем размер стека (256 байт)
.data                            ; Начало сегмента данных
mas dw 2 DUP (5 DUP (?)) ; Массив чисел: 2 строки по 5 элементов (всего 10 слов)
res db '     $'                 ; Строка для вывода результата, заканчивается символом '$'
newl db 0Ah, 0Dh, '$'           ; Строка переноса строки (LF и CR), заканчивается символом '$'
.386                             ; Указываем, что используем инструкции процессора x86
.code                            ; Начало сегмента кода
org 100h                        ; Указываем адрес начала программы

start:                          ; Метка начала программы
    mov AX, @data               ; Загружаем адрес сегмента данных в регистр AX
    mov DS, AX                  ; Переносим адрес сегмента данных в регистр DS

    ; Ввод четных чисел: 2, 4, 6, 8, 10
    mov CX, 5                   ; Устанавливаем размер массива для первой строки (5 элементов)
    mov BX, 2                   ; Первое четное число
    mov SI, 0                   ; Начальное смещение в массиве

input_even:                     ; Метка для цикла ввода четных чисел
    mov mas[SI], BX             ; Записываем текущее значение BX в массив по смещению SI
    add BX, 2                   ; Увеличиваем BX на 2 для следующего четного числа
    add SI, 2                   ; Переходим к следующему элементу массива (по два байта)
    loop input_even             ; Уменьшаем CX и повторяем цикл пока CX не станет равным нулю

    ; Ввод нечетных чисел: 1, 3, 5, 7, 9
    mov CX, 5                   ; Устанавливаем размер массива для второй строки (5 элементов)
    mov BX, 1                   ; Первое нечетное число
    mov SI, 10                  ; Смещение для второй строки (начинается с 10)

input_odd:                      ; Метка для цикла ввода нечетных чисел
    mov mas[SI], BX             ; Записываем текущее значение BX в массив по смещению SI
    add BX, 2                   ; Увеличиваем BX на 2 для следующего нечетного числа
    add SI, 2                   ; Переходим к следующему элементу массива (по два байта)
    loop input_odd              ; Уменьшаем CX и повторяем цикл пока CX не станет равным нулю

    ; Вывод чисел из массива
    mov CX, 2                   ; Количество строк для вывода (две строки)
    mov SI, 0                   ; Начальное смещение в массиве

output:                         
    push CX                     ; Сохраняем значение CX на стеке

    ; Вывод первой строки (четные числа)
    mov CX, 5                   ; Устанавливаем количество элементов для вывода первой строки
output_even:                    ; Метка для цикла вывода четных чисел
    mov ax, mas[SI]            ; Загружаем значение из массива в регистр AX
    call numoutput              ; Вызываем процедуру вывода числа
    add SI, 2                   ; Переходим к следующему элементу массива (по два байта)
    loop output_even            ; Уменьшаем CX и повторяем цикл пока CX не станет равным нулю

    mov DX, offset newl         ; Загружаем адрес переноса строки в DX
    call lineoutput              ; Вызываем процедуру вывода строки переноса

    ; Вывод второй строки (нечетные числа)
    mov SI, 10                  ; Переходим ко второй строке (смещение на 10)
    
    mov CX, 5                   ; Устанавливаем количество элементов для вывода второй строки 
output_odd:                     ; Метка для цикла вывода нечетных чисел
    mov ax, mas[SI]            ; Загружаем значение из массива в регистр AX 
    call numoutput              ; Вызываем процедуру вывода числа 
    add SI, 2                   ; Переходим к следующему элементу массива (по два байта) 
    loop output_odd             ; Уменьшаем CX и повторяем цикл пока CX не станет равным нулю
    
    mov DX, offset newl         ; Загружаем адрес переноса строки в DX 
    call lineoutput              ; Вызываем процедуру вывода строки переноса


    pop CX                      ; Восстанавливаем значение CX из стека 
    mov AX, 4C00h               ; Завершаем программу 
    int 21h                     ; Вызов прерывания DOS для завершения программы 

lineoutput proc                  ; Процедура вывода строки 
    push AX                     ; Сохраняем значение AX на стеке 
    mov ah, 09h                ; Номер функции DOS для вывода строки 
    int 21h                    ; Вызов прерывания DOS 
    pop AX                     ; Восстанавливаем значение AX из стека 
    ret                         ; Возврат из процедуры 

charoutput proc                 ; Процедура вывода символа 
    push AX                    ; Сохраняем значение AX на стеке 
    MOV ah,02h                 ; AH – номер функции для вывода символа 
    INT 21h                    ; Инициализация прерывания DOS 
    pop AX                     ; Восстанавливаем значение AX из стека 
    ret                         ; Возврат из процедуры 

numoutput proc                  ; Процедура преобразования числа в строку для вывода 
    pusha                       ; Сохраняем все регистры на стеке 

  ; Преобразование числа в строку для вывода 
  mov bx,10                    ; Основание системы счисления (десятичная) 
  mov cx,0                     ; Обнуляем счетчик цифр 

met:                            ; Метка начала цикла преобразования числа 
  xor dx,dx                  ; Обнуляем DX перед делением 
  div bx                      ; Делим AX на BX (результат в AX, остаток в DX) 
  push dx                     ; Сохраняем остаток от деления (цифру) в стеке 
  inc cx                      ; Увеличиваем счетчик цифр на единицу 
  cmp ax,0                   ; Проверяем условие: если неполное частное равно нулю 
  jne met                    ; Если нет — продолжаем цикл 

  mov di,5                    ; Устанавливаем начальную позицию для записи цифр в строку результата 
  sub di,cx                   ; Вычисляем позицию для записи цифр 

outp:                          ; Метка начала цикла записи цифр в строку результата 
  pop dx                      ; Извлекаем цифру из стека 
  add dl,'0'                  ; Преобразуем число в ASCII (добавляем смещение) 
  mov res[di],dl             ; Записываем цифру в строку результата по позиции di 
  inc di                      ; Переходим к следующей позиции в строке результата 
  loop outp                  ; Повторяем пока есть цифры 

  mov dx,offset res           ; Загружаем адрес результата в DX для его вывода 
  call lineoutput;            ; Вызываем процедуру вывода результата 
  call strclear               ; Очищаем строку результата после вывода 
  popa                       ; Восстанавливаем все регистры с помощью popa  
  ret                         ; Возврат из процедуры 

numoutput endp                ; Конец процедуры numoutput 

proc strclear                 ; Процедура очистки строки с результатом  
pusha                         ; Сохраняем все регистры на стеке  
mov cx,4                        ; Количество пробелов для очистки строки  
mov di,4                        ; Начальная позиция  

stclrlp:                        ; Метка начала цикла очистки  
mov res[di],' '                ; Заполняем пробелами  
dec di                         ; Переходим к предыдущей позиции  
loop stclrlp                   ; Повторяем пока cx не станет равным нулю  

popa                           ; Восстанавливаем все регистры  
ret                           ; Возврат из процедуры  

strclear endp                 ; Конец процедуры strclear 

end start                      ; Конец программы и указание точки входа
