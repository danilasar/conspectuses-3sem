= Элементы архитектуры ПК и ассемблер для IBM PC
Ассемблер может обрабатывать целые десятичные, шестнадцатеричные, действительные с плавающей точкой, строковые и символьные константы.
- Двоичные целые --- последовательность нулей и единиц, заканчивающихся символом b
- Десятичные --- обычные положительные и отрицательные или заканчивающиеся символом d числа
- Шестнадцатеричные заканчиваются символом h или, если константа начинается с цифр ABCDEF, перед ней можно записать нолик.
- Действительные с плавающей точкой представляются в виде мантиссы и порядка, где буква e --- основание системы, умноженное в соответствующую степень (0.547e-2, 34.751e+02)
- Символьные данные
/ Строки: --- последовательности символов, заключённые в апострофы '' или кавычки ""

В ассемблере есть именованные константы, определяемые директивой equ:
```nasm
m equ 27
```

Переменные в ассемблере определяются с помощью директив определения данных и памяти или с помощью директивы равенства
```nasm
v1 db ?
v2 dw 34
v3 = 100
v3 = v3 + 1
```
Константы в основном используются как операнды в выражениях или в директивах определения данных и памяти.

Выражения строятся из операндов, операторов и скобок. Операнды --- это константы и переменные, операторы --- это знаки операций (арифметические [ADD +, SUB -, MUL \*, DIV /, DIV %], логические [NOT !, AND &, OR |, XOR ^], операции отношений [LT \<, LE \<=, NE !=, GT >, GE >=], операции сдвига [SHL \<\<, SHR >>], специальные _военные_ операции [OFFSET, PTR]).

- Арифметические операции: `+`, `-`, `\*`, /, mod
- Логические операции: and, or, xor
- Операции отношений записываются с помощью символов `lt` ($<$), `le` ($<=$), `ne` ($eq.not$), `eq` ($=$), `gt` ($>$), `ge` ($>=$)
- Спецоперации: `offset`, `ptr`
 - `offset имя`, где `имя` --- имя переменной или метка, --- смещение относительно начала сегмента
 - `[размер] ptr имя` --- тип операнда (BYTE, WORD, DWORD, FWORD, QWORD, TWORD)
 - `near` --- ближний тип вызова
 - `far` --- дальний тип вызова

== Директива определения
Директива определения данных и памяти имеет вид, соответствующий общему виду директив.

[\<name>] DX \<операнды> \<;комментарии>, где X это B, W, D, F, Q, T

Вот они, слева направо: `db, dw, dd, de, dq, dt`.

/ Операнды: --- это одна или несколько констант, разделённых запятыми. Директива выделяет в памяти определённое количество полей памяти, присваивая имени адрес первого байта в выделенной области памяти.

Если операндом в этой директиве является символическое имя, которому уже поставлен в соответствие какой-то адрес, а это мы могли делать с помощью другой такой же директивы (например)

В поле операндов может быть "?", одна или несколько констант, разделенных запятой. Имя если оно есть определяет адрес первого байта выделяемой обасти. Директивой выделяется указанное кол-во байтов ОП и указанные операнды пересылаются в эти поля памяти. Если опеанд --- это "?", то в соответсвующее поле ничего не заносится. Пример:
```nasm R1 DB 0, 0, 0```: выделено 3 поля, заполненных "0"



Если мы хотим выделить 100 полей определённого размера и заполнить их одним и тем же значением, то для этого можно использовать специальный повторитель `dup`.

С помощью этой же директивы мы можем определить одномерный массив, прописав элементы через запятую.

```nasm
m dd im1                ; двойное слово --- адрес im1
d db 100 dup(1)         ; 100 байт 0x01
mas dw 1, 7, 35, 75, 84 ; одномерный массив слов
```

Определим двумерный массив:
```nasm
arr db 7, 14, 11, -5
    db 5, 0, 1, 2
    db -5, 0, 15, 24
```

Строковые константы можно определить с длиной вплоть до 255 символов. Команда определения слова определит широкосимвольную строку.

Команда `int` прерывает работу процессора.

Чтобы вывести на экран '!', необходимо:
```nasm
mov ah, 6
mov di, '!'
int 21h
```

```nasm D DB Const DUP (?)``` --- выделить 100 байт в памяти. В диретиве определения байта (слова) вмместо Const должна стоять константа, максимально допустимое значение --- 255 (65535).

== Команды работы со стеком
Команда прерывания int рерывает работу процессора, передаёт управление операционной системе или BIOS и после выполнения этой программы управление передаётся команде, следующей за int. Выполняемые действия будут зависеть от операнда, параметра int и содержания некоторых регистров:
```nasm int 0x21 ```

Например, чтобы выести на экран "!" необходимо:
```nasm
MOV AH, 6 
MOV DL "!"
INT 21h
```

Адрес начала сегмента стека загружается в регистр `ss` операционной системой автоматически. На вершину стека указывает регистр `sp` (`esp`, `rsp`). Добавить элемент в стек --- команда `push операнд`, где операнд --- регистр или переменная. Для взятия из стека используется `pop операнд`.

Чтобы работать со всеми регистрами, существуют команды `push a` и `pop a`. Они позволяют положить в стек и считать из стека регистры общего назначения в следующей последовательности: `ax`, `bx`, `cx`, `as`, `bs`, `cs`, `si`, `di`.

Для 32-разрядных регистров существуют `push ad` и `pop ad`, работающие с `eax, ebx, ecx, edx, esp, ebp, esi, edi`.

Чтобы не удалять данные из стека, используют регистр `bp`:
```nasm
mov bp, sp      ; (sp) -> bp
mov ax, [bp+6]  ; (ss:(bp - 6)) -> ax
```

- ```nasm push <операнд>``` --- положить элемент на вершину стека (операндом может быть как регистр, так и переменная)
- ```nasm pop <операнд>``` --- убрать элемент с вершины стека и положить в операнд
- ```nasm pusha```/```nasm popa``` --- позвояет положить/убрать содержимое всех регистров общего назначения в последовательности: `ax`, `bx`, `cx`, `dx`, `sp`, `bp`, `si`, `di`
- ```nasm pushad/popad``` --- то же самое, но _вроде как_ для 32-битных регистров

К любому элементу стека можно обратиться следующим образом:
```nasm
mov bp, sp ; bp = sp
```

Пересылаем 4 байта из одной области памяти в другую в обратной последовательности и выводим их на экран:
```nasm
title print.asm ; определяет заголовок листинга программы, там может быть до 60 символов
page ,120 ; определяет количество строк на странице листинга и количество символов в строке (количество строк по умолчанию, символов до 120, в теории максимум 132), может использоваться без параметров, тогда она осуществляет переход на следующую страницу листинга
Sseg Segment Para stack 'stack'
    db 100h dup (?)
sseg ends
DSeg Segment Para Public 'data'
    dan db '1', '3', '5', '7'
    rez db 4 dup (?)
dseg ends

CSeg Segment Para Public 'code'
    assume ss:SSeg, ds:DSeg, cs:CSeg
Start proc far
    push ds
    xor ax, ax
    push ax ; положили пустое слово
    mov ax, dsex
    mov ds, ax
    mov ah, 6
    mov dl, dan + 3
    mov rez, dl
    int 21h
    mov dl, dan + 2
    mov rez + 1, dl
    int 21h
    mov dl, dan + 1
    mov rez + 2, dl
    int 21h
    mov dl, dan
    mov rez, dl
    int 21h
Start endp
CSeg ends
end Start
```


== Директива сегмента
```nasm
<имя> Segment <ReadOnly> <выравнивание> <тип> <размер> <класс>
```

Любой из операндов может отсутствовать 

- Если есть `ReadOnly`, то будет выведено сообщение об ошибку при попытке записи в сегмент
- Операнд выравнивания влияет на адрес начала сегмента: в зависимости от вида выравнивания адрес начала округляется до 8, 16, 32 или 128 двоичных разрядов.
 - `BYTE` --- адрес начала может быть любым
 - `WORD` --- адрес начала сегмента кратен 2 
 - `DWORD` --- адрес начала сегмента кратен 4
 - `Para` --- адрес начала сегмента кратен 16 (по умолчанию)

PAGE --- адрес начала мегмента кратен 256 

- Тип определяет тип обхединения сегмнтов 
 - Значение `stack` указывается в сегменте стека для остальных сегмнотов public. Если такой параметр при сутствует, то все сегменты с одним именем и различными классами объединяются в порядке их записи.
 - Значение `Common` говорит, что сегменты с одним именем объеденины, но не последовательно, а с одного и того же адреса так что сегмент должен располагаться по абсолютному адресу, определенному операнду выражения
 - Значение `Private` означает, что это сегмент ни с каким другим объединяться не должен 
- \<разрядность>
 - `use 16` --- сегмент до 64 КБ 
 - `Use 32` --- сегмент до 4 ГБ
- \<класс> --- с одинаковым классом сегменты располагаются в исполняемом файле последовательностью друг за другом

== Точечные директивы
В программе на ассемблере могут использоваться упрощённые (точечные) директивы

*.MODEL* --- директива, определяющая модель выделяемой памяти 


```nasm
.model small
.data
st1     db 'Line1', '$'
st2     db 'Line2', '$'
st3     db 'Line3', '$'
.code
begin: mov ax, @data ; заносим в сегментный регистр ds
       mov ds, ax    ; физический адрес сегмента данных
mov ah, 9 ; номер функции вывода строки на экран
mov dx, offset st1 ; адрес st1 должен содержаться в регистре dx
int 21h
mov dx, offset st2
int 21h
...........
mov ax, 4c00h
int 21h
end begin
```

`$` --- конец строки, которую необходимо вывести на экран.

В результате выполнения программы:
```
Line1 Line2 Line3
```
Если необходимо построчно, нельзя забывать про байты 13, 10 (они же 0dh, 0ah).


= .COM-файлы 

После обработки компилятором и редактором связей получаем exe-файл, который содержит блок начальной загруски, размером не менее 512 байт, но существует возможность создания другого вида исполняемого файла --- com --- который может быть получен при использовании модели tiny.
